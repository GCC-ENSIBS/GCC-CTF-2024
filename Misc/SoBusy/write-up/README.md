# SoBusy

Author: Drahoxx

By reading the challenge's description, we can imagine that someone put a backdoor on the machine that can allow us to elevate our privileges and gain access to the superuser account (root).

One way to grant root privileges to others is to use the suid bit on an executable. So, it is always useful to check for those.

The manual way to find those binaries is described on [Hacktrick - Privilege Escalation - Sudo and Suid](https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid) using the find command, but anyhow, `linpeas` does it automatically.

```sh
gccprod@e74e96c86e66:~$ find /usr/ -perm -4000
/usr/bin/passwd
/usr/bin/ls
/usr/bin/chsh
/usr/bin/su
/usr/bin/mount
/usr/bin/chfn
/usr/bin/newgrp
/usr/bin/umount
/usr/bin/gpasswd
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/openssh/ssh-keysign
```

Among those executables, one stands-out : `/usr/bin/ls`. Why `ls` would have the suid bit set?

Your first instinct might dictates you to check on [gtfobin](https://gtfobins.github.io/) for any tricks to get a shell. But nothing about `ls`.

If we try and give wrong arguments to ls, the following message appears:
```sh
$ ls -e
ls: invalid option -- 'e'
BusyBox v1.36.1 (2024-02-07 20:35:31 CET) multi-call binary.
...
```
So it seems that the `ls` binary is not the original debian `ls` binary we are used to (note: its size is pretty huge too, which may indicates that something is wrong with that binary).

Looking online, we can see that "BusyBox is a software suite that provides several Unix utilities in a single executable file. It runs in a variety of POSIX environments such as Linux, Android, and FreeBSD, although many of the tools it provides are designed to work with interfaces provided by the Linux".

Looking further into it, we understand that Busybox uses the `argv[0]` parameter in order to execute the code corresponding to the desired command. *It can be understood by looking into classical embedded systems like the ones generated by Buildroot. They commonly have the busybox binary and multiple symlinks (sh, ls, grep,...) pointing to it.*

So, to abuse it, we will fake the `argv[0]` of the program and pass `sh` instead of `ls`.
Searching the web, we easly find a stackoverflow post explaining how to do it: https://stackoverflow.com/a/23330268/13751917 

```sh
$ exec -a sh /usr/bin/ls
```

We got a shell! Now, we can cat the flag.

```sh
~Â # cat /root/flag.txt
GCC{BusyBox_H4s_M0r3_Opti0ns_Th4n_LS}
```

~ Keep pwn
